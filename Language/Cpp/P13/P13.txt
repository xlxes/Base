1.
基类的公有成员成为派生类的公有成员。基类的保护成员成为派生类的保护成员，基类的私有成员被继承，但是不能直接访问。

2.
不能继承构造函数、析构函数、赋值运算符和友元。

3.
如果返回是void那么任可使用单独赋值但是不可连续赋值
如果返回的是值而不是对象的引用，那么执行速度会稍慢，因为返回语句需要复制对象

4.
按照派生的顺序调用构造函数，最早的构造函数最先调用，而析构函数的调用正好相反。

5.
需要，每个类都需要其构造函数，如果派生类没有添加任何数据成员则构造函数可以为空，但是必须有。

6.
只调用派生类的方法，它取代基类的定义。仅当派生类没有重新定义方法或使用作用域解析运算符的时候，才会调用基类方法。但是，应该把所有要重新定义的函数声明为虚函数。

7.
如果派生类的构造函数使用new new[]来初始化指针成员时，则应定义一个赋值运算符。

8.
可以将派生类的对象地址赋给基类指针，但是只有通过显示转换才能将基类地址赋给派生类的指针，而这样的转换并不一定安全。

9.
派生类的对象可以赋给基类对象（使用基类的赋值运算符），但是仅当派生类中定义类转换运算符或使用基类为参数的赋值运算符时，才能将基类对象赋值给派生类对象。

10.
因为C++允许基类引用指向从基类派生而来的任何类型

11.
按值传递对象将调用复制构造函数，由于形参为基类对象，因此将调用基类的复制构造函数，复制构造函数以基类引用为参数，该引用可以指向作为参数传递的派生对象。最终生成一个新的基类对象，其成员对应于派生对象的基类部分。

12.
按引用传递可以确保虚函数的作用，另外可节省时间和内存，同时使用const同样可以达到保护数据的目的。

13.
如果head是常规非需方法，将调用基类方法
如果是虚函数，调用派生类的方法

14.
本方法不是一种is-a关系，不适合公有继承，同时派生类中的area隐藏了基类中的area方法
